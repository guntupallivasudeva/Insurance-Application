import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { CommonModule, Location } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { RouterModule, NavigationEnd } from '@angular/router';
import { AuthService } from '../../services/auth.service';
import { AdminService } from '../../services/admin.service';
import { VerificationService } from '../../services/verification.service';
import { PaymentService } from '../../services/payment.service';
import { forkJoin } from 'rxjs';
import { filter } from 'rxjs/operators';

@Component({
  selector: 'app-admin-dashboard',
  standalone: true,
  imports: [ CommonModule, FormsModule, RouterModule],
  templateUrl: './admin-dashboard.html'
})
export class AdminDashboard implements OnInit {
  roleTitle = 'Admin';
  userName = 'User';
  isLoading = false;
  errorMessage = '';
  successMessage = '';
  isLoadingPending = false;
  pendingError = '';
  pendingClaims: Array<any> = [];
  
  // Active tab for navigation
  activeTab = 'pending-policies';
  // Approved claims
  approvedClaimsLoading = false;
  approvedClaimsError = '';
  approvedClaims: Array<any> = [];
  actionError = '';
  // Claim edit modal state
  editingClaim: any = null;
  claimForm: any = { incidentDate: '', description: '', amountClaimed: null, decisionNotes: '' };
  // Processed (Approved/Rejected) claims and All claims
  processedClaimsLoading = false;
  processedClaimsError = '';
  processedClaims: Array<any> = [];
  allClaimsLoading = false;
  allClaimsError = '';
  allClaims: Array<any> = [];
  // Policies
  isLoadingPolicies = false;
  policiesError = '';
  pendingPolicies: Array<any> = [];
  policies: Array<any> = [];
  policyProductsById: Record<string, any> = {};
  policiesLoading = false;
  policiesCrudError = '';
  // Delete confirmation modal
  showDeleteModal = false;
  deleteTarget: any = null;
  deleteTargetType: '' | 'policy' | 'agent' = '';
  deleteLoading = false;
  // Policy modal state
  managePolicyModal = false;
  policyForm: any = { _id: '', code: '', title: '', description: '', premium: null, termMonths: null, minSumInsured: null, maxSumInsured: null, assignedAgentId: '' };
  policyFormMode: 'create' | 'edit' = 'create';
  policyFormError = '';
  // Track original code to avoid accidental overwrite when user clears field during edit
  originalPolicyCode: string = '';
  // Digits portion entered by user (without POL prefix)
  policyCodeDigits: string = '';
  // User Policies (all)
  userPoliciesLoading = false;
  userPoliciesError = '';
  userPolicies: Array<any> = [];
  // Approved policies
  approvedPoliciesLoading = false;
  approvedPoliciesError = '';
  approvedPolicies: Array<any> = [];
  // Modals
  showPolicyModal = false;
  selectedPolicy: any = null;
  showAssignModal = false;
  agentList: Array<any> = [];
  isLoadingAgents = false;
  assignError = '';
  selectedAgentId: string = '';
  // Unassign (remove agent from policy) modal state
  showUnassignModal = false;
  unassignTarget: any = null;
  unassignLoading = false;
  unassignError = '';
  // Agents list (for dashboard display)
  agentsLoading = false;
  agentsError = '';
  agents: Array<any> = [];
  manageAgentModal = false;
  agentFormMode: 'create' | 'edit' = 'create';
  agentForm: any = { _id: '', name: '', email: '', password: '' };
  agentFormError = '';
  // Agent Code digits-only input (user types number only; 'AGT' is added automatically)
  agentCodeDigits: string = '';
  // Auto email generation tracking for new agent
  private lastAutoGeneratedEmail: string = '';
  private lastAutoName: string = '';
  private emailManuallyEdited: boolean = false;
  // Customer details aggregated
  customerDetailsLoading = false;
  customerDetailsError = '';
  customerDetails: Array<any> = [];
  // Customer modal
  showCustomerModal = false;
  selectedCustomer: any = null;
  // User Policies overview & modal state
  userPoliciesSearch: string = '';
  showUserPoliciesModal = false;
  selectedUserPoliciesCustomer: any = null;
  // Generic "View" modals state
  showAgentViewModal = false;
  selectedAgentView: any = null;
  showPolicyProductViewModal = false;
  selectedPolicyProductView: any = null;
  showClaimViewModal = false;
  selectedClaimView: any = null;

  // Confirmation and success modals for approve/reject actions
  showConfirmModal = false;
  showSuccessModal = false;
  confirmModalData: any = null;
  successModalData: any = null;
  pendingAction: any = null;

  // Computation helpers for counts referenced in template (avoid complex lambdas inline)
  policyCountByStatus(list: any[], status: string): number {
    if (!Array.isArray(list)) return 0;
    const target = status.toLowerCase();
    return list.filter(p => (p?.status || '').toLowerCase() === target).length;
  }
  policyCountClaimed(list: any[]): number {
    if (!Array.isArray(list)) return 0;
    return list.filter(p => ['claimed','cancelled'].includes((p?.status || '').toLowerCase())).length;
  }

  // Compute payment status (Paid / Delayed / Pending / Failed) without using disallowed template syntax
  computePaymentStatus(pay: any): string {
    try {
      if (!pay) return 'Pending';
      const raw = (pay.status || '').toString().trim().toLowerCase();
      if (raw === 'failed') return 'Failed';
      const paidAt = this.computePaidDate(pay);
      const dueAt = this.computeDueDate(pay);
      const isDone = raw === 'done' || raw === 'paid' || !!paidAt;
      
      // If payment is made, it should always show as "Paid" regardless of timing
      if (paidAt || isDone) {
        return 'Paid';
      }
      
      // If payment is not made and past due date, show as "Delayed"
      if (dueAt && dueAt.getTime() < Date.now()) {
        return 'Delayed';
      }
      
      // Default to "Pending" for future payments
      return 'Pending';
    } catch {
      return 'Pending';
    }
  }

  // ---- Payment schedule helpers (per selectedUserPoliciesCustomer modal) ----
  private getPolicyIdFromPayment(pay: any): string | null {
    const ref = pay?.userPolicyId;
    if (!ref) return null;
    if (typeof ref === 'string') return ref;
    if (typeof ref === 'object') return ref?._id || null;
    return null;
  }

  private resolvePolicyForPayment(pay: any): any | null {
    const pid = this.getPolicyIdFromPayment(pay);
    const list = this.selectedUserPoliciesCustomer?.policies;
    if (!pid || !Array.isArray(list)) return null;
    return list.find((p: any) => (p?._id || p?.id) === pid) || null;
  }

  private paymentsForPolicy(policyId: string): any[] {
    const pays = this.selectedUserPoliciesCustomer?.payments;
    if (!Array.isArray(pays)) return [];
    const rows = pays.filter((x: any) => {
      const ref = x?.userPolicyId;
      const id = typeof ref === 'string' ? ref : (ref?._id || null);
      return id === policyId;
    });
    // sort by datePaid (or createdAt) ascending
    return rows.sort((a: any, b: any) => {
      const ta = new Date(a?.datePaid || a?.createdAt || 0).getTime();
      const tb = new Date(b?.datePaid || b?.createdAt || 0).getTime();
      return ta - tb;
    });
  }

  private paymentIndex(pay: any): number {
    const pid = this.getPolicyIdFromPayment(pay);
    if (!pid) return 0;
    const list = this.paymentsForPolicy(pid);
    // identify by _id if present; else by timestamp order and reference fallback
    const id = pay?._id || pay?.id;
    if (id) {
      const idx = list.findIndex((x: any) => (x?._id || x?.id) === id);
      if (idx >= 0) return idx;
    }
    // fallback: locate by timestamp match
    const ts = new Date(pay?.datePaid || pay?.createdAt || 0).getTime();
    const idx2 = list.findIndex((x: any) => new Date(x?.datePaid || x?.createdAt || 0).getTime() === ts);
    return idx2 >= 0 ? idx2 : 0;
  }

  private addMonths(date: Date, months: number): Date {
    const d = new Date(date);
    const day = d.getDate();
    d.setMonth(d.getMonth() + months);
    // handle month overflow (e.g., adding to Jan 31)
    if (d.getDate() < day) {
      d.setDate(0); // last day of previous month
    }
    return d;
  }

  computePaidDate(pay: any): Date | null {
    const d = pay?.datePaid || pay?.createdAt || pay?.updatedAt;
    const dt = d ? new Date(d) : null;
    return dt && !isNaN(dt.getTime()) ? dt : null;
  }

  computeDueDate(pay: any): Date | null {
    const pol = this.resolvePolicyForPayment(pay);
    const start = pol?.startDate ? new Date(pol.startDate) : null;
    if (!start || isNaN(start.getTime())) return null;
    const idx = this.paymentIndex(pay);
    return this.addMonths(start, idx);
  }

  computeNextDueDate(pay: any): Date | null {
    const pol = this.resolvePolicyForPayment(pay);
    const start = pol?.startDate ? new Date(pol.startDate) : null;
    if (!start || isNaN(start.getTime())) return null;
    const idx = this.paymentIndex(pay) + 1;
    // If termMonths known, stop after term
    const term = pol?._product?.termMonths ?? pol?.policyProductId?.termMonths ?? null;
    if (typeof term === 'number' && term > 0 && idx >= term) return null;
    return this.addMonths(start, idx);
  }
  kpis: { userPolicies: number; policies: number; claims: number; customers: number; agents: number; totalPayments: number; totalRevenue: number } = {
    userPolicies: 0,
    policies: 0,
    claims: 0,
    customers: 0,
    agents: 0,
    totalPayments: 0,
    totalRevenue: 0
  };

  // Database status
  dbStatus: {
    connection?: { code: number; state: string; host?: string | null; dbName?: string | null };
    counts?: { users: number; agents: number; admins: number; policies: number; userPolicies: number; claims: number; payments: number; auditLogs: number } | null;
    serverTime?: string;
  } = {};

  constructor(
    private auth: AuthService,
  private router: Router,
  private location: Location,
    private adminService: AdminService,
    public verificationService: VerificationService,
    public paymentService: PaymentService
  ) {
    const role = (this.auth.getRole() || 'Admin').toString();
    this.roleTitle = role.charAt(0).toUpperCase() + role.slice(1).toLowerCase();
    const user = this.auth.getUser();
    this.userName = user?.name || user?.email || 'User';
    // Keep active tab synced on browser navigation within the same component instance
    this.router.events.pipe(filter(e => e instanceof NavigationEnd)).subscribe((evt: any) => {
      const url = evt?.urlAfterRedirects || evt?.url || this.router.url || '';
      this.updateActiveTabFromUrl(url);
    });
  }

  // TrackBy helper to reduce DOM churn and flicker in ngFor card grids
  trackById(_index: number, item: any) {
    return item?._id || item?.id || item?.code || item?.email || _index;
  }

  setActiveTab(tab: string) {
    this.activeTab = tab;
    // keep URL in sync so cards open as separate routes
    const base = '/admin-dashboard';
    const current = this.router.url;
    if (!current.endsWith('/' + tab)) {
      // Navigate without reloading guards or losing state; still the same component
      this.router.navigate([base, tab]);
    }
  }

  // Back navigation for section pages. Uses browser history when available, otherwise
  // navigates back to the fixed admin dashboard landing.
  goBack() {
    try {
      if (window && window.history && window.history.length > 1) {
        this.location.back();
        return;
      }
    } catch {}
    this.router.navigate(['/admin-dashboard']);
  }

  private calculatePaymentStats(): { totalPayments: number; totalRevenue: number } {
    let totalPayments = 0;
    let totalRevenue = 0;
    if (Array.isArray(this.customerDetails)) {
      this.customerDetails.forEach((customer: any) => {
        if (Array.isArray(customer.payments)) {
          totalPayments += customer.payments.length;
          customer.payments.forEach((payment: any) => {
            if (payment?.amount && typeof payment.amount === 'number') {
              totalRevenue += payment.amount;
            }
          });
        }
      });
    }
    return { totalPayments, totalRevenue };
  }

  // Helper method to calculate total paid amount for a customer
  getCustomerTotalPaid(customer: any): number {
    if (!customer?.payments || !Array.isArray(customer.payments)) {
      return 0;
    }
    return customer.payments.reduce((total: any, payment: any) => {
      return total + (payment?.amount || 0);
    }, 0);
  }

  private updateActiveTabFromUrl(url: string) {
    try {
      const seg = (url || '').split('/').filter(Boolean);
      const idx = seg.indexOf('admin-dashboard');
      const maybe = idx >= 0 ? seg[idx + 1] : '';
      const allowed = new Set(['pending-policies','approved-policies','agents','policies','user-policies','customers','claims']);
      // If a child segment exists and is allowed, set it; otherwise, clear to show only the main cards page
      this.activeTab = maybe && allowed.has(maybe) ? maybe : '' as any;
    } catch {
      this.activeTab = '' as any;
    }
  }

  ngOnInit() {
    // Derive activeTab for initial load
    this.updateActiveTabFromUrl(this.router.url || '');

    this.loadSummary();
    this.loadDbStatus();
    this.loadPendingClaims();
    this.loadPendingPolicies();
    this.loadApprovedClaims();
    this.loadAllClaims();
    this.loadApprovedPolicies();
    this.loadUserPolicies();
    this.loadAgents();
    this.loadPolicies();
    this.loadCustomerDetails();
  }

  // Single entry-point to refresh the whole dashboard at once
  refreshAll() {
    // Ensure fresh DB status on explicit refresh
    this.adminService.invalidateDbStatusCache();
    this.adminService.invalidateAgentsCache();
    this.adminService.invalidatePoliciesCache();
    this.adminService.invalidateUserPoliciesCache();
    this.adminService.invalidateClaimsCache();
    this.adminService.invalidateCustomerDetailsCache();
    this.adminService.invalidateSummaryCache();
    this.loadSummary();
    this.loadDbStatus();
    this.loadPendingClaims();
    this.loadPendingPolicies();
    this.loadApprovedClaims();
    this.loadAllClaims();
    this.loadApprovedPolicies();
    this.loadUserPolicies();
    this.loadAgents();
    this.loadPolicies();
    this.loadCustomerDetails();
  }

  loadDbStatus() {
    this.adminService.getDbStatusCached().subscribe({
      next: (res) => {
        this.dbStatus = res || {};
      },
      error: () => {
        this.dbStatus = { connection: { code: -1, state: 'unknown' } } as any;
      }
    });
  }

  loadSummary() {
    this.isLoading = true;
    this.errorMessage = '';
    // Use cached endpoints to compute counts efficiently without flicker
    forkJoin({
      userPoliciesRes: this.adminService.getAllUserPoliciesCached(),
      claimsRes: this.adminService.getAllClaimsCached(),
      customersRes: this.adminService.getAllCustomerDetailsCached(),
      agentsRes: this.adminService.getAllAgentsCached(),
      policiesRes: this.adminService.getAllPoliciesCached()
    }).subscribe({
      next: (all: any) => {
        const policiesList = Array.isArray(all?.userPoliciesRes?.policies)
          ? all.userPoliciesRes.policies
          : (Array.isArray(all?.userPoliciesRes?.data) ? all.userPoliciesRes.data : (Array.isArray(all?.userPoliciesRes) ? all.userPoliciesRes : []));
        const claimsList = Array.isArray(all?.claimsRes?.claims)
          ? all.claimsRes.claims
          : (Array.isArray(all?.claimsRes?.data) ? all.claimsRes.data : (Array.isArray(all?.claimsRes) ? all.claimsRes : []));
        const customersList = Array.isArray(all?.customersRes?.data)
          ? all.customersRes.data
          : (Array.isArray(all?.customersRes?.customers) ? all.customersRes.customers : (Array.isArray(all?.customersRes) ? all.customersRes : []));
        const agentsList = Array.isArray(all?.agentsRes?.agents)
          ? all.agentsRes.agents
          : (Array.isArray(all?.agentsRes?.data) ? all.agentsRes.data : (Array.isArray(all?.agentsRes) ? all.agentsRes : []));
        const policyProductsList = Array.isArray(all?.policiesRes?.data)
          ? all.policiesRes.data
          : (Array.isArray(all?.policiesRes) ? all.policiesRes : []);

        this.kpis = {
          userPolicies: policiesList.length,
          policies: policyProductsList.length,
          claims: claimsList.length,
          customers: customersList.length,
          agents: agentsList.length,
          totalPayments: 0,
          totalRevenue: 0
        };
        // Calculate payment stats if customer details are available
        const { totalPayments, totalRevenue } = this.calculatePaymentStats();
        this.kpis.totalPayments = totalPayments;
        this.kpis.totalRevenue = totalRevenue;
        this.isLoading = false;
      },
      error: () => {
        // Fallback to summary endpoint if list endpoints fail
        this.adminService.getSummaryKPIsCached().subscribe({
          next: (res: any) => {
            const userPolicies = Number(res?.policiesSold ?? 0); // approximation
            const claims = Number(res?.claimsPending ?? 0) + Number(res?.claimsApproved ?? 0);
            const customers = Number(res?.usersCount ?? 0);
            const agents = Number(res?.agentsCount ?? 0);

            // Try to fetch policy products count separately
            this.adminService.getAllPoliciesCached().subscribe({
              next: (polRes: any) => {
                const policyProductsList = Array.isArray(polRes?.data) ? polRes.data : (Array.isArray(polRes) ? polRes : []);
                this.kpis = { userPolicies, policies: policyProductsList.length, claims, customers, agents, totalPayments: 0, totalRevenue: 0 };
                this.isLoading = false;
              },
              error: () => {
                this.kpis = { userPolicies, policies: 0, claims, customers, agents, totalPayments: 0, totalRevenue: 0 };
                this.isLoading = false;
              }
            });
          },
          error: () => {
            this.errorMessage = 'Unable to load admin summary. Please try again later.';
            this.isLoading = false;
          }
        });
      }
    });
  }

  // Lightweight summary update that only refreshes if needed
  loadSummaryCached() {
    // Use cache for navigation-only loads to prevent flicker
    this.loadSummary();
  }

  // Comprehensive refresh after any action - invalidates all caches and reloads data
  refreshAfterAction() {
    // Invalidate all caches to ensure fresh data
    this.adminService.invalidateDbStatusCache();
    this.adminService.invalidateAgentsCache();
    this.adminService.invalidatePoliciesCache();
    this.adminService.invalidateUserPoliciesCache();
    this.adminService.invalidateClaimsCache();
    this.adminService.invalidateCustomerDetailsCache();
    this.adminService.invalidateSummaryCache();
    
    // Reload all dashboard sections
    this.loadSummary();
    this.loadDbStatus();
    this.loadPendingClaims();
    this.loadPendingPolicies();
    this.loadApprovedClaims();
    this.loadAllClaims();
    this.loadApprovedPolicies();
    this.loadUserPolicies();
    this.loadAgents();
    this.loadPolicies();
    this.loadCustomerDetails();
  }

  // Load all claims once and derive processed (approved/rejected)
  loadAllClaims() {
    this.allClaimsLoading = true;
    this.processedClaimsLoading = true;
    this.allClaimsError = '';
    this.processedClaimsError = '';
    this.adminService.getAllClaimsCached().subscribe({
      next: (res: any) => {
        const claims = Array.isArray(res?.claims) ? res.claims : (Array.isArray(res?.data) ? res.data : []);
        const normStatus = (s: any) => (s || '').toString().toLowerCase();
        // Sort all by createdAt desc if available
        this.allClaims = [...claims].sort((a: any, b: any) => {
          const ta = new Date(a?.createdAt || 0).getTime();
          const tb = new Date(b?.createdAt || 0).getTime();
          return tb - ta;
        });
        this.processedClaims = this.allClaims.filter((c: any) => {
          const st = normStatus(c?.status);
          return st === 'approved' || st === 'rejected';
        });
        this.allClaimsLoading = false;
        this.processedClaimsLoading = false;
      },
      error: (err) => {
        const msg = err?.error?.error || err?.message || 'Unknown error';
        this.allClaimsError = `Unable to load claims. ${msg}`;
        this.processedClaimsError = `Unable to load approved/rejected claims. ${msg}`;
        this.allClaimsLoading = false;
        this.processedClaimsLoading = false;
      }
    });
  }

  // Policies CRUD list
  loadPolicies() {
    this.policiesLoading = true;
    this.policiesCrudError = '';
    this.adminService.getAllPoliciesCached().subscribe({
      next: (res: any) => {
        const list = Array.isArray(res?.data) ? res.data : (Array.isArray(res) ? res : []);
        // sort by code numeric portion ascending, then by full code as fallback
        this.policies = [...list].sort((a: any, b: any) => {
          const ac = (a?.code || '').toString();
          const bc = (b?.code || '').toString();
          const an = this.extractCodeNumber(ac);
          const bn = this.extractCodeNumber(bc);
          if (an !== bn) return an - bn;
          return ac.localeCompare(bc);
        });
        // build quick lookup map for policy products
        this.policyProductsById = {};
        for (const prod of this.policies) {
          if (prod && prod._id) this.policyProductsById[prod._id] = prod;
        }
        this.policiesLoading = false;
      },
      error: (err) => {
        const msg = err?.error?.error || err?.message || 'Unknown error';
        this.policiesCrudError = `Unable to load policies. ${msg}`;
        this.policiesLoading = false;
      }
    });
  }

  openCreatePolicy() {
    const nextCode = this.generateNextPolicyCode();
    const nextDigits = this.extractDigitsFromCode(nextCode);
    this.policyForm = { _id: '', code: nextCode, title: '', description: '', premium: null, termMonths: null, minSumInsured: null, maxSumInsured: null, assignedAgentId: '' };
    this.policyFormMode = 'create';
    this.policyFormError = '';
    this.managePolicyModal = true;
    this.originalPolicyCode = '';
    this.policyCodeDigits = nextDigits;
    
    // Ensure agents are loaded for the dropdown
    if (!this.agents || this.agents.length === 0) {
      console.log('Loading agents for policy modal...');
      this.loadAgents();
    }
  }

  openEditPolicy(p: any) {
    console.log('Edit Policy - Original policy data:', p);
    this.policyForm = {
      _id: p?._id || '',
      code: p?.code || '',
      title: p?.title || '',
      description: p?.description || '',
      premium: p?.premium ?? null,
      termMonths: p?.termMonths ?? null,
      minSumInsured: p?.minSumInsured ?? null,
      maxSumInsured: p?.maxSumInsured ?? null,
      assignedAgentId: p?.assignedAgentId || ''
    };
    console.log('Edit Policy - Form populated with:', this.policyForm);
    this.policyFormMode = 'edit';
    this.policyFormError = '';
    this.managePolicyModal = true;
    this.originalPolicyCode = p?.code || '';
    this.policyCodeDigits = this.extractDigitsFromCode(p?.code || '');
  }

  closeManagePolicyModal() {
    this.managePolicyModal = false;
  }



  savePolicy() {
    this.policiesCrudError = '';
    this.policyFormError = '';
    const payload: any = {};
    // Handle code carefully: avoid overwriting with placeholder when editing & blanked
    if (this.policyFormMode === 'create') {
      payload.code = this.policyForm.code?.trim() || this.composeFullCodeFromDigits(this.policyCodeDigits);
    } else if (this.policyFormMode === 'edit') {
      const rawDigits = (this.policyCodeDigits || '').trim();
      if (rawDigits) {
        const full = this.composeFullCodeFromDigits(rawDigits);
        if (full !== this.originalPolicyCode) {
          payload.code = full;
        }
      }
    }
    payload.title = this.policyForm.title?.trim();
    payload.description = this.policyForm.description?.trim();
    payload.premium = Number(this.policyForm.premium);
    payload.termMonths = Number(this.policyForm.termMonths);
    if (this.policyForm.minSumInsured != null && this.policyForm.minSumInsured !== '') payload.minSumInsured = Number(this.policyForm.minSumInsured);
    if (this.policyForm.maxSumInsured != null && this.policyForm.maxSumInsured !== '') payload.maxSumInsured = Number(this.policyForm.maxSumInsured);

    if (this.policyFormMode === 'create') {
      this.adminService.addPolicy(payload).subscribe({
        next: (response) => {
          console.log('Policy created successfully:', response);
          // If agent is selected, assign the policy to the agent
          if (this.policyForm.assignedAgentId) {
            console.log('Assigning policy to agent:', this.policyForm.assignedAgentId);
            const policyId = response?.policy?._id || response?.data?._id;
            if (policyId) {
              this.adminService.assignPolicyToAgent(policyId, this.policyForm.assignedAgentId).subscribe({
                next: (assignResponse) => {
                  console.log('Agent assigned successfully:', assignResponse);
                  this.managePolicyModal = false;
                  this.refreshAfterAction();
                },
                error: (err) => {
                  console.error('Failed to assign agent:', err);
                  // Policy created but agent assignment failed
                  this.policyFormError = `Policy created but failed to assign agent: ${err?.error?.message || err.message}`;
                }
              });
            } else {
              console.error('Policy ID not found in response:', response);
              this.policyFormError = 'Policy created but could not assign agent - policy ID not found';
            }
          } else {
            console.log('No agent selected, policy created without assignment');
            this.managePolicyModal = false;
            this.refreshAfterAction();
          }
        },
        error: (err) => {
          const msg = err?.error?.message || err?.error?.errors?.join?.(', ') || err?.message || 'Unknown error';
          this.policyFormError = `Failed to add policy. ${msg}`;
        }
      });
    } else {
      const id = this.policyForm._id;
      const updatePayload: any = {};
      ['code','title','description','premium','termMonths','minSumInsured','maxSumInsured'].forEach((k: string) => {
        const v = (payload as any)[k];
        if (v !== undefined && v !== null && v !== '' && !(k === 'code' && !this.policyForm.code?.trim())) {
          (updatePayload as any)[k] = v;
        }
      });
      // If code field was emptied, do NOT include code -> preserves original unique code
      this.adminService.updatePolicy(id, updatePayload).subscribe({
        next: () => {
          // Handle agent assignment for edit mode
          if (this.policyForm.assignedAgentId) {
            this.adminService.assignPolicyToAgent(id, this.policyForm.assignedAgentId).subscribe({
              next: () => {
                this.managePolicyModal = false;
                this.refreshAfterAction();
              },
              error: (err) => {
                console.error('Failed to assign agent during edit:', err);
                // Policy updated but agent assignment failed
                this.managePolicyModal = false;
                this.refreshAfterAction();
              }
            });
          } else {
            // Check if we need to unassign agent (if assignedAgentId is empty but policy had an agent)
            // For now, just close modal - you can add unassign logic here if needed
            this.managePolicyModal = false;
            this.refreshAfterAction();
          }
        },
        error: (err) => {
          const msg = err?.error?.message || err?.error?.errors?.join?.(', ') || err?.message || 'Unknown error';
          this.policyFormError = `Failed to update policy. ${msg}`;
        }
      });
    }
  }

  // Normalize code to 'POL' + digits provided by admin. Examples:
  // '123' -> 'POL123', 'pol001' -> 'POL001', 'POL' -> 'POL'
  private normalizePolicyCode(input: any): string {
    const raw: string = (input ?? '').toString().trim();
    if (!raw) return 'POL';
    // if it already starts with POL (any case) and has following digits, standardize case
    const m = raw.match(/^\s*pol\s*0*([0-9]+)\s*$/i);
    if (m) {
      return `POL${m[1]}`;
    }
    // extract digits anywhere in the string
    const digits = raw.replace(/\D+/g, '');
    if (digits) return `POL${digits}`;
    // fallback to POL as base
    return 'POL';
  }

  // Extract the numeric portion of a code like 'POL123' for sorting
  private extractCodeNumber(code: string): number {
    const m = (code || '').match(/(\d+)/);
    return m ? parseInt(m[1], 10) : Number.MAX_SAFE_INTEGER;
  }

  // Extract just the digit sequence after POL (case-insensitive). Preserves leading zeros by returning match exactly.
  private extractDigitsFromCode(code: string): string {
    const m = (code || '').match(/^[Pp][Oo][Ll](\d*)$/);
    if (m) return m[1] || '';
    // Fallback: strip non-digits
    return (code || '').replace(/[^0-9]/g, '');
  }

  // Build full code from digits. If empty, returns 'POL'. Pads (optional) to at least 2 digits when user enters a single digit.
  private composeFullCodeFromDigits(digits: string): string {
    let d = (digits || '').replace(/[^0-9]/g, '');
    if (!d) return 'POL';
    // If user entered a single digit, pad to two for visual consistency (01, 02, etc.)
    if (d.length === 1) d = '0' + d;
    return 'POL' + d;
  }

  // Generate the next policy code automatically
  private generateNextPolicyCode(): string {
    let maxNumber = 0;
    // Find the highest existing policy number
    for (const policy of this.policies || []) {
      const num = this.extractCodeNumber(policy.code || '');
      if (num !== Number.MAX_SAFE_INTEGER && num > maxNumber) {
        maxNumber = num;
      }
    }
    // Generate next number (start from 1 if no policies exist)
    const nextNumber = maxNumber + 1;
    // Format with leading zeros (minimum 2 digits)
    const formatted = nextNumber.toString().padStart(2, '0');
    return `POL${formatted}`;
  }

  // When user types code digits, keep internal full code preview updated (for edit mode display)
  onCodeDigitsChange() {
    if (this.policyFormMode === 'edit') {
      const full = this.composeFullCodeFromDigits(this.policyCodeDigits);
      // Do not immediately mutate originalPolicyCode; just update preview (policyForm.code) so user sees change
      this.policyForm.code = full;
    }
  }

  // Called when user types in digits-only Policy Code field; updates full code with 'POL' prefix
  onPolicyCodeDigitsInput() {
    let d = (this.policyCodeDigits || '').replace(/[^0-9]/g, '');
    if (d.length > 6) d = d.slice(0, 6);
    this.policyCodeDigits = d;
    if (!d) {
      this.policyForm.code = '';
      return;
    }
    const padded = d.length === 1 ? '0' + d : d;
    this.policyForm.code = 'POL' + padded;
  }

  // ---- Agent Code helpers (editable with auto-fill on create) ----
  private extractAgentCodeNumber(code: string): number {
    const m = (code || '').toUpperCase().match(/^AGT(\d+)$/);
    return m ? parseInt(m[1], 10) : 0;
  }
  private suggestNextAgentCode(): string {
    let max = 0;
    for (const a of this.agents || []) {
      const n = this.extractAgentCodeNumber((a?.agentCode || '').toString());
      if (n > max) max = n;
    }
    const next = (max || 0) + 1;
    const digits = String(next).padStart(2, '0');
    return `AGT${digits}`;
  }

  // Called when user types in digits-only Agent Code field; updates full code with 'AGT' prefix
  onAgentCodeDigitsInput() {
    let d = (this.agentCodeDigits || '').replace(/[^0-9]/g, '');
    if (d.length > 6) d = d.slice(0, 6);
    this.agentCodeDigits = d;
    if (!d) {
      this.agentForm.agentCode = '';
      return;
    }
    const padded = d.length === 1 ? '0' + d : d;
    this.agentForm.agentCode = 'AGT' + padded;
  }

  deletePolicy(id: string) {
    this.policiesCrudError = '';
    if (!id) return;
    this.deleteLoading = true;
    this.adminService.deletePolicy(id).subscribe({
      next: () => {
        this.deleteLoading = false;
        this.showDeleteModal = false;
        this.deleteTarget = null;
        this.deleteTargetType = '';
        this.refreshAfterAction();
        this.successMessage = 'Policy deleted successfully.';
      },
      error: (err) => {
        this.deleteLoading = false;
        const msg = err?.error?.message || err?.message || 'Unknown error';
        this.policiesCrudError = `Failed to delete policy. ${msg}`;
      }
    });
  }
  private fetchCountsFallback() {
    // Refined counts using actual endpoint shapes
    forkJoin({
      userPoliciesRes: this.adminService.getAllUserPolicies(), // { success, policies }
      claimsRes: this.adminService.getAllClaims(), // { success, claims }
      customersRes: this.adminService.getAllCustomers(), // { success, data: [{ customer, policies, payments }, ...] }
      agentsRes: this.adminService.getAllAgents(), // { success, agents }
      policiesRes: this.adminService.getAllPolicies() // { success, data }
    }).subscribe({
      next: (all: any) => {
        const policiesList = Array.isArray(all?.userPoliciesRes?.policies)
          ? all.userPoliciesRes.policies
          : (Array.isArray(all?.userPoliciesRes?.data) ? all.userPoliciesRes.data : (Array.isArray(all?.userPoliciesRes) ? all.userPoliciesRes : []));
        const claimsList = Array.isArray(all?.claimsRes?.claims)
          ? all.claimsRes.claims
          : (Array.isArray(all?.claimsRes?.data) ? all.claimsRes.data : (Array.isArray(all?.claimsRes) ? all.claimsRes : []));
        const customersList = Array.isArray(all?.customersRes?.data)
          ? all.customersRes.data
          : (Array.isArray(all?.customersRes?.customers) ? all.customersRes.customers : (Array.isArray(all?.customersRes) ? all.customersRes : []));
        const agentsList = Array.isArray(all?.agentsRes?.agents)
          ? all.agentsRes.agents
          : (Array.isArray(all?.agentsRes?.data) ? all.agentsRes.data : (Array.isArray(all?.agentsRes) ? all.agentsRes : []));
        const policyProductsList = Array.isArray(all?.policiesRes?.data)
          ? all.policiesRes.data
          : (Array.isArray(all?.policiesRes) ? all.policiesRes : []);

        this.kpis = {
          userPolicies: policiesList.length,
          policies: policyProductsList.length,
          claims: claimsList.length,
          customers: customersList.length,
          agents: agentsList.length,
          totalPayments: 0,
          totalRevenue: 0
        };
        this.isLoading = false;
      },
      error: () => {
        this.errorMessage = 'Unable to load admin summary. Please try again later.';
        this.isLoading = false;
      }
    });
  }

  loadPendingClaims() {
    this.isLoadingPending = true;
    this.pendingError = '';
    this.adminService.getPendingClaims().subscribe({
      next: (res: any) => {
        const claims = Array.isArray(res?.claims) ? res.claims : (Array.isArray(res?.data) ? res.data : []);
        this.pendingClaims = claims
          .filter((c: any) => (c?.status || '').toLowerCase() === 'pending')
          .slice(0, 5)
          .map((c: any) => {
            const prod = this.resolvePolicyProductForClaim(c);
            const nested = c?.userPolicyId?.policyProductId;
            const code = prod?.code ?? nested?.code ?? null;
            const title = prod?.title ?? nested?.title ?? null;
            return { ...c, _product: prod || nested || null, _policyCode: code, _policyTitle: title };
          });
        this.isLoadingPending = false;
      },
      error: () => {
        this.pendingError = 'Unable to load pending claims.';
        this.isLoadingPending = false;
      }
    });
  }

  // Attempt to resolve the Policy Product object for a given claim using multiple possible shapes
  private resolvePolicyProductForClaim(c: any): any | null {
    if (!c) return null;
    // Common locations the product might appear
    const ref = c.userPolicyId;
    const direct = c.policyProductId || c._product;
    const nested = ref?.policyProductId || ref?._product;

    // If already an object with expected fields, return it
    const candidate = direct || nested;
    if (candidate && typeof candidate === 'object') return candidate;

    // If it's an id string, try lookup from cached map built elsewhere
    const id = typeof candidate === 'string'
      ? candidate
      : (typeof ref?.policyProductId === 'string' ? ref.policyProductId : null);
    if (id && this.policyProductsById && this.policyProductsById[id]) return this.policyProductsById[id];

    return null;
  }

  loadApprovedClaims() {
    this.approvedClaimsLoading = true;
    this.approvedClaimsError = '';
    this.adminService.getAllClaimsCached().subscribe({
      next: (res: any) => {
        const claims = Array.isArray(res?.claims) ? res.claims : (Array.isArray(res?.data) ? res.data : []);
        this.approvedClaims = claims
          .filter((c: any) => (c?.status || '').toLowerCase() === 'approved')
          .slice(-5) // last 5 approved (assuming backend returns chronological)
          .reverse();
        this.approvedClaimsLoading = false;
      },
      error: () => {
        this.approvedClaimsError = 'Unable to load approved claims.';
        this.approvedClaimsLoading = false;
      }
    });
  }

  loadPendingPolicies() {
    this.isLoadingPolicies = true;
    this.policiesError = '';
    this.adminService.getAllUserPoliciesCached().subscribe({
      next: (res: any) => {
        // Controller returns { success, policies }
        const list = Array.isArray(res?.policies)
          ? res.policies
          : (Array.isArray(res?.data) ? res.data : (Array.isArray(res) ? res : []));
        this.pendingPolicies = list
          .filter((p: any) => (p?.status || '').toLowerCase() === 'pending')
          .slice(0, 5);
        this.isLoadingPolicies = false;
      },
      error: (err) => {
        console.error('Failed to load user policies:', err);
        const msg = err?.error?.error || err?.message || 'Unknown error';
        this.policiesError = `Unable to load pending policies. ${msg}`;
        this.isLoadingPolicies = false;
      }
    });
  }

  loadApprovedPolicies() {
    this.approvedPoliciesLoading = true;
    this.approvedPoliciesError = '';
    this.adminService.getAllUserPoliciesCached().subscribe({
      next: (res: any) => {
        const list = Array.isArray(res?.policies) ? res.policies : (Array.isArray(res?.data) ? res.data : (Array.isArray(res) ? res : []));
        this.approvedPolicies = list
          .filter((p: any) => (p?.status || '').toLowerCase() === 'approved')
          .slice(-5)
          .reverse();
        this.approvedPoliciesLoading = false;
      },
      error: (err) => {
        console.error('Failed to load approved policies:', err);
        const msg = err?.error?.error || err?.message || 'Unknown error';
        this.approvedPoliciesError = `Unable to load approved policies. ${msg}`;
        this.approvedPoliciesLoading = false;
      }
    });
  }

  // All user policies (across statuses)
  loadUserPolicies() {
    this.userPoliciesLoading = true;
    this.userPoliciesError = '';
    this.adminService.getAllUserPoliciesCached().subscribe({
      next: (res: any) => {
        const list = Array.isArray(res?.policies)
          ? res.policies
          : (Array.isArray(res?.data) ? res.data : (Array.isArray(res) ? res : []));
        // Show most recent 10 by createdAt if available
        this.userPolicies = [...list].sort((a: any, b: any) => {
          const ta = new Date(a?.createdAt || 0).getTime();
          const tb = new Date(b?.createdAt || 0).getTime();
          return tb - ta;
        }).slice(0, 10);
        this.userPoliciesLoading = false;
      },
      error: (err) => {
        console.error('Failed to load user policies:', err);
        const msg = err?.error?.error || err?.message || 'Unknown error';
        this.userPoliciesError = `Unable to load user policies. ${msg}`;
        this.userPoliciesLoading = false;
      }
    });
  }

  approve(claimId: string) {
    const claim = this.pendingClaims.find(c => c._id === claimId);
    this.showConfirmationModal(
      'Approve Claim',
      `Are you sure you want to approve this claim?`,
      `Claim ID: ${claimId}`,
      claim ? `Amount: ₹${claim.amountClaimed}` : '',
      'approve-claim',
      claimId
    );
  }

  confirmApproveClaim(claimId: string) {
    this.actionError = '';
    this.showConfirmModal = false;
    // optimistic update: remove from list immediately
    const original = [...this.pendingClaims];
    this.pendingClaims = this.pendingClaims.filter(c => c._id !== claimId);
    this.adminService.approveClaim(claimId).subscribe({
      next: () => {
        // Comprehensive refresh to update all sections
        this.refreshAfterAction();
        this.showSuccessMessage('Success!', 'Claim has been approved successfully.');
      },
      error: () => {
        this.actionError = 'Failed to approve claim.';
        this.pendingClaims = original; // revert on error
      }
    });
  }

  reject(claimId: string) {
    const claim = this.pendingClaims.find(c => c._id === claimId);
    this.showConfirmationModal(
      'Reject Claim',
      `Are you sure you want to reject this claim?`,
      `Claim ID: ${claimId}`,
      claim ? `Amount: ₹${claim.amountClaimed}` : '',
      'reject-claim',
      claimId
    );
  }

  confirmRejectClaim(claimId: string) {
    this.actionError = '';
    this.showConfirmModal = false;
    const original = [...this.pendingClaims];
    this.pendingClaims = this.pendingClaims.filter(c => c._id !== claimId);
    this.adminService.rejectClaim(claimId).subscribe({
      next: () => {
        this.refreshAfterAction();
        this.showSuccessMessage('Success!', 'Claim has been rejected.');
      },
      error: () => {
        this.actionError = 'Failed to reject claim.';
        this.pendingClaims = original;
      }
    });
  }

  // --- Claim Edit Modal Handlers ---
  openEditClaim(c: any) {
    this.actionError = '';
    this.editingClaim = c;
    this.claimForm = {
      incidentDate: c?.incidentDate ? this.formatDateForInput(c.incidentDate) : '',
      description: c?.description || '',
      amountClaimed: c?.amountClaimed ?? null,
      decisionNotes: c?.decisionNotes || ''
    };
  }

  closeEditClaim() {
    this.editingClaim = null;
    this.claimForm = { incidentDate: '', description: '', amountClaimed: null, decisionNotes: '' };
    this.actionError = '';
  }

  saveClaimEdit() {
    if (!this.editingClaim?._id) { this.actionError = 'Missing claim id.'; return; }
    const payload: any = {};
    if (this.claimForm.incidentDate) {
      // send as ISO string for consistency
      const d = new Date(this.claimForm.incidentDate);
      if (!isNaN(d.getTime())) payload.incidentDate = d.toISOString();
    }
    if (typeof this.claimForm.description === 'string') payload.description = this.claimForm.description.trim();
    if (this.claimForm.amountClaimed != null && this.claimForm.amountClaimed !== '') payload.amountClaimed = Number(this.claimForm.amountClaimed);
    if (typeof this.claimForm.decisionNotes === 'string') payload.decisionNotes = this.claimForm.decisionNotes.trim();

    this.adminService.updateClaim(this.editingClaim._id, payload).subscribe({
      next: (res: any) => {
        // Try to use returned claim; otherwise patch current one
        const updated = res?.claim || res?.data || { ...this.editingClaim, ...payload };
        this.pendingClaims = this.pendingClaims.map(c => c._id === this.editingClaim._id ? { ...c, ...updated } : c);
        this.closeEditClaim();
        this.successMessage = 'Claim updated.';
        this.refreshAfterAction();
      },
      error: (err) => {
        const msg = err?.error?.message || err?.message || 'Unknown error';
        this.actionError = `Failed to update claim. ${msg}`;
      }
    });
  }

  private formatDateForInput(d: string | Date): string {
    const date = new Date(d);
    if (isNaN(date.getTime())) return '';
    const yyyy = date.getFullYear();
    const mm = String(date.getMonth() + 1).padStart(2, '0');
    const dd = String(date.getDate()).padStart(2, '0');
    return `${yyyy}-${mm}-${dd}`;
  }

  approvePolicy(userPolicyId: string) {
    const policy = this.pendingPolicies.find(p => p._id === userPolicyId);
    this.showConfirmationModal(
      'Approve Policy',
      `Are you sure you want to approve this policy?`,
      `Policy ID: ${userPolicyId}`,
      policy ? `User: ${policy.userId?.name || policy.userId?.email || 'N/A'}` : '',
      'approve-policy',
      userPolicyId
    );
  }

  confirmApprovePolicy(userPolicyId: string) {
    this.actionError = '';
    this.showConfirmModal = false;
    const original = [...this.pendingPolicies];
    this.pendingPolicies = this.pendingPolicies.filter(p => p._id !== userPolicyId);
    this.adminService.approveUserPolicy(userPolicyId).subscribe({
      next: () => {
        this.refreshAfterAction();
        this.showSuccessMessage('Success!', 'Policy has been approved successfully.');
      },
      error: () => {
        this.actionError = 'Failed to approve policy.';
        this.pendingPolicies = original;
      }
    });
  }

  rejectPolicy(userPolicyId: string) {
    const policy = this.pendingPolicies.find(p => p._id === userPolicyId);
    this.showConfirmationModal(
      'Reject Policy',
      `Are you sure you want to reject this policy?`,
      `Policy ID: ${userPolicyId}`,
      policy ? `User: ${policy.userId?.name || policy.userId?.email || 'N/A'}` : '',
      'reject-policy',
      userPolicyId
    );
  }

  confirmRejectPolicy(userPolicyId: string) {
    this.actionError = '';
    this.showConfirmModal = false;
    const original = [...this.pendingPolicies];
    this.pendingPolicies = this.pendingPolicies.filter(p => p._id !== userPolicyId);
    this.adminService.rejectUserPolicy(userPolicyId).subscribe({
      next: () => {
        this.refreshAfterAction();
        this.showSuccessMessage('Success!', 'Policy has been rejected.');
      },
      error: () => {
        this.actionError = 'Failed to reject policy.';
        this.pendingPolicies = original;
      }
    });
  }

  // View policy details modal
  viewPolicyDetails(policy: any) {
    this.selectedPolicy = policy;
    this.showPolicyModal = true;
  }

  closePolicyModal() {
    this.showPolicyModal = false;
    this.selectedPolicy = null;
  }

  // Assign agent modal
  openAssignAgent(policy: any) {
    this.selectedPolicy = policy;
    this.selectedAgentId = '';
    this.assignError = '';
    this.showAssignModal = true;
    if (!this.agentList.length) {
      this.isLoadingAgents = true;
      this.adminService.getAllAgents().subscribe({
        next: (res: any) => {
          const list = Array.isArray(res?.agents) ? res.agents : (Array.isArray(res?.data) ? res.data : []);
          this.agentList = list;
          this.isLoadingAgents = false;
        },
        error: () => {
          this.assignError = 'Unable to load agents.';
          this.isLoadingAgents = false;
        }
      });
    }
  }

  closeAssignModal() {
    this.showAssignModal = false;
    this.selectedPolicy = null;
    this.selectedAgentId = '';
  }

  assignAgent() {
    if (!this.selectedPolicy || !this.selectedAgentId) {
      this.assignError = 'Please select an agent.';
      return;
    }
    this.assignError = '';
    // Support both shapes: UserPolicy (has policyProductId) and PolicyProduct (has _id)
    const candidate1 = this.selectedPolicy?.policyProductId?._id || (typeof this.selectedPolicy?.policyProductId === 'string' ? this.selectedPolicy?.policyProductId : null);
    const candidate2 = this.selectedPolicy?._id || null;
    const policyProductId = candidate1 || candidate2;
    if (!policyProductId) {
      this.assignError = 'Unable to determine policy product id.';
      return;
    }
    const request$ = this.adminService.assignPolicyToAgent(policyProductId, this.selectedAgentId);
    request$.subscribe({
      next: () => {
        this.closeAssignModal();
        // Refresh entire dashboard after assignment
        this.refreshAfterAction();
      },
      error: (err) => {
        const msg = err?.error?.message || err?.message || 'Unknown error';
        this.assignError = `Failed to assign agent. ${msg}`;
      }
    });
  }

  // Remove currently assigned agent from a policy product
  unassignAgent(policy: any) {
    if (!policy) return;
    // Determine policy product id similarly to assign
    const candidate1 = policy?.policyProductId?._id || (typeof policy?.policyProductId === 'string' ? policy?.policyProductId : null);
    const candidate2 = policy?._id || null;
    const policyProductId = candidate1 || candidate2;
    if (!policyProductId) return;
    this.adminService.unassignPolicyFromAgent(policyProductId).subscribe({
      next: () => {
        // Refresh entire dashboard after unassignment
        this.refreshAfterAction();
        this.showUnassignModal = false;
        this.unassignTarget = null;
        this.unassignLoading = false;
      },
      error: (err) => {
        const msg = err?.error?.message || err?.message || 'Unknown error';
        this.assignError = `Failed to unassign agent. ${msg}`;
        this.unassignLoading = false;
      }
    });
  }

  openUnassignModal(policy: any) {
    this.unassignTarget = policy;
    this.unassignError = '';
    this.showUnassignModal = true;
    this.unassignLoading = false;
  }

  closeUnassignModal() {
    if (this.unassignLoading) return;
    this.showUnassignModal = false;
    this.unassignTarget = null;
    this.unassignError = '';
  }

  confirmUnassignAgent() {
    if (!this.unassignTarget || this.unassignLoading) return;
    this.unassignLoading = true;
    this.unassignError = '';
    this.unassignAgent(this.unassignTarget);
  }

  // Load agents for dashboard display
  loadAgents() {
    this.agentsLoading = true;
    this.agentsError = '';
    this.adminService.getAllAgentsCached().subscribe({
      next: (res: any) => {
        this.agents = Array.isArray(res?.agents) ? res.agents : (Array.isArray(res?.data) ? res.data : []);
        // sort by agent code
        this.agents.sort((a: any, b: any) => {
          const codeA = a?.agentCode || '';
          const codeB = b?.agentCode || '';
          return codeA.localeCompare(codeB);
        });
        this.agentsLoading = false;
      },
      error: (err) => {
        const msg = err?.error?.error || err?.message || 'Unknown error';
        this.agentsError = `Unable to load agents. ${msg}`;
        this.agentsLoading = false;
      }
    });
  }

  // Agent CRUD UI handlers
  openCreateAgent() {
    this.agentFormMode = 'create';
    const nextCode = this.suggestNextAgentCode();
    const nextDigits = (nextCode.match(/\d+/)?.[0] || '').padStart(2, '0');
    this.agentForm = { _id: '', name: '', email: '', password: 'agent123', assignedPolicyIds: [], assignedPolicyId: '', agentCode: `AGT${nextDigits}` };
    this.agentCodeDigits = nextDigits;
    this.agentFormError = '';
    this.manageAgentModal = true;
    this.lastAutoGeneratedEmail = '';
    this.lastAutoName = '';
    this.emailManuallyEdited = false;
  }

  openEditAgent(a: any) {
    this.agentFormMode = 'edit';
    this.agentForm = { _id: a?._id || '', name: a?.name || '', email: a?.email || '', password: '', assignedPolicyIds: [], assignedPolicyId: '', agentCode: a?.agentCode || '' };
    this.agentCodeDigits = (a?.agentCode || '').toString().replace(/[^0-9]/g, '');
    this.agentFormError = '';
    this.manageAgentModal = true;
    this.lastAutoGeneratedEmail = '';
    this.lastAutoName = '';
    this.emailManuallyEdited = true; // never auto-overwrite in edit mode
  }

  closeManageAgentModal() {
    this.manageAgentModal = false;
    this.agentForm = { _id: '', name: '', email: '', password: '', assignedPolicyIds: [], assignedPolicyId: '', agentCode: '' };
    this.agentCodeDigits = '';
    this.agentFormError = '';
  }

  saveAgent(): void {
    this.agentFormError = '';
    const payload: any = {
      name: (this.agentForm.name || '').trim(),
      email: (this.agentForm.email || '').trim()
    };
    const rawCode: string = (this.agentForm.agentCode || '').trim();
    const codeValid = !rawCode || /^AGT\d{2,}$/i.test(rawCode);
    if (!codeValid) {
      this.agentFormError = 'Agent Code must match pattern AGT## (e.g., AGT01).';
      return;
    }
    if (rawCode) payload.agentCode = rawCode.toUpperCase();
    if (this.agentFormMode === 'create') {
      if (this.agentForm.password) {
        if (this.agentForm.password.length < 6) {
          this.agentFormError = 'Password must be at least 6 characters.';
          return;
        }
        payload.password = this.agentForm.password;
      }
      this.adminService.createAgent(payload).subscribe({
        next: (res) => {
          const createdId = res?.agent?._id || res?.data?._id;
          // reflect auto-generated agent code in form (for UX)
          if (res?.agent?.agentCode) {
            this.agentForm.agentCode = res.agent.agentCode;
          }
          const assignList: string[] = [];
          if (Array.isArray(this.agentForm.assignedPolicyIds) && this.agentForm.assignedPolicyIds.length) {
            assignList.push(...this.agentForm.assignedPolicyIds);
          } else if (this.agentForm.assignedPolicyId) {
            assignList.push(this.agentForm.assignedPolicyId);
          }
          if (createdId && assignList.length) {
            this.assignPoliciesToAgentSequential(createdId, assignList, () => {
              this.manageAgentModal = false;
              this.refreshAfterAction();
            });
          } else {
            this.manageAgentModal = false;
            this.refreshAfterAction();
          }
        },
        error: (err) => {
          const msg = err?.error?.message || err?.error?.errors?.join?.(', ') || err?.message || 'Unknown error';
          this.agentFormError = `Failed to create agent. ${msg}`;
        }
      });
    } else {
      if (this.agentForm.password) {
        if (this.agentForm.password.length < 6) {
          this.agentFormError = 'New password must be at least 6 characters.';
          return;
        }
        payload.password = this.agentForm.password;
      }
      const id = this.agentForm._id;
      this.adminService.updateAgent(id, payload).subscribe({
        next: (res: any) => {
          if (res?.agent?.agentCode) {
            this.agentForm.agentCode = res.agent.agentCode;
          }
          const assignList: string[] = [];
          if (Array.isArray(this.agentForm.assignedPolicyIds) && this.agentForm.assignedPolicyIds.length) {
            assignList.push(...this.agentForm.assignedPolicyIds);
          } else if (this.agentForm.assignedPolicyId) {
            assignList.push(this.agentForm.assignedPolicyId);
          }
          if (assignList.length) {
            this.assignPoliciesToAgentSequential(id, assignList, () => {
              this.manageAgentModal = false;
              this.refreshAfterAction();
            });
          } else {
            this.manageAgentModal = false;
            this.refreshAfterAction();
          }
        },
        error: (err) => {
          const msg = err?.error?.message || err?.error?.errors?.join?.(', ') || err?.message || 'Unknown error';
          this.agentFormError = `Failed to update agent. ${msg}`;
        }
      });
    }
  }

  // Assign multiple policies to an agent sequentially to reuse existing admin endpoint
  private assignPoliciesToAgentSequential(agentId: string, policyIds: string[], done: () => void) {
    if (!policyIds.length) { done(); return; }
    const [first, ...rest] = policyIds;
    this.adminService.assignPolicyToAgent(first, agentId).subscribe({
      next: () => this.assignPoliciesToAgentSequential(agentId, rest, done),
      error: () => this.assignPoliciesToAgentSequential(agentId, rest, done) // continue even if one fails
    });
  }

  deleteAgent(id: string) {
    if (!id) return;
    this.deleteLoading = true;
    this.adminService.deleteAgent(id).subscribe({
      next: () => {
        this.deleteLoading = false;
        this.showDeleteModal = false;
        this.deleteTarget = null;
        this.deleteTargetType = '';
        this.refreshAfterAction();
        this.successMessage = 'Agent deleted successfully.';
      },
      error: (err) => {
        this.deleteLoading = false;
        const msg = err?.error?.message || err?.message || 'Unknown error';
        this.agentsError = `Failed to delete agent. ${msg}`;
      }
    });
  }

  // Unified delete modal handlers
  openDeleteModal(type: 'policy' | 'agent', entity: any) {
    this.deleteTargetType = type;
    this.deleteTarget = entity;
    this.showDeleteModal = true;
    this.deleteLoading = false;
  }

  closeDeleteModal() {
    if (this.deleteLoading) return; // prevent closing while processing
    this.showDeleteModal = false;
    this.deleteTarget = null;
    this.deleteTargetType = '';
  }

  confirmDelete() {
    if (!this.deleteTargetType || !this.deleteTarget) return;
    if (this.deleteTargetType === 'policy') {
      this.deletePolicy(this.deleteTarget._id);
    } else if (this.deleteTargetType === 'agent') {
      this.deleteAgent(this.deleteTarget._id);
    }
  }

  // Customer details (customer + policies + payments)
  loadCustomerDetails() {
    this.customerDetailsLoading = true;
    this.customerDetailsError = '';
    this.adminService.getAllCustomerDetailsCached().subscribe({
      next: (res: any) => {
        this.customerDetails = Array.isArray(res?.data) ? res.data : [];
        // prefill product details from populated objects or cache; fetch as-needed in background
        this.prefillCustomerPolicies();
        // Update payment stats after loading customer details
        const { totalPayments, totalRevenue } = this.calculatePaymentStats();
        this.kpis.totalPayments = totalPayments;
        this.kpis.totalRevenue = totalRevenue;
        this.customerDetailsLoading = false;
      },
      error: (err) => {
        const msg = err?.error?.error || err?.message || 'Unknown error';
        this.customerDetailsError = `Unable to load customer details. ${msg}`;
        this.customerDetailsLoading = false;
      }
    });
  }

  // When expanding a customer card, hydrate missing policy product details on demand
  onToggleCustomerCard(c: any) {
    c.expanded = !c.expanded;
    if (!c.expanded || !Array.isArray(c.policies)) return;
    for (const pol of c.policies) {
      const product = pol?.policyProductId;
      // If policyProductId is just an ObjectId string or missing key fields, fetch full product
      const needsFetch = !product || typeof product === 'string' || !product.code || !product.title;
      if (needsFetch) {
        const productId = typeof product === 'string' ? product : pol?.policyProductId?._id || pol?.policyProductId;
        if (productId) {
          // Try to hydrate from cache first
          const cached = this.policyProductsById[productId];
          if (cached) {
            pol.policyProductId = cached;
            pol._product = cached;
            continue;
          }
          this.adminService.getPolicyById(productId).subscribe({
            next: (r: any) => {
              if (r?.success && r?.policy) {
                pol.policyProductId = r.policy;
                pol._product = r.policy;
                this.policyProductsById[r.policy._id] = r.policy;
              }
            },
            error: () => {
              // swallow; leave as-is
            }
          });
        }
      }
        // populated already
        pol._product = product;
    }
  }

  // Open modal for customer details (replaces inline expand UX)
  openCustomerModal(c: any) {
    this.selectedCustomer = c;
    this.showCustomerModal = true;
    // Hydrate policies similar to toggle logic
    if (c && Array.isArray(c.policies)) {
      for (const pol of c.policies) {
        const product = pol?.policyProductId;
        const needsFetch = !product || typeof product === 'string' || !product.code || !product.title;
        if (needsFetch) {
          const productId = typeof product === 'string' ? product : pol?.policyProductId?._id || pol?.policyProductId;
          if (productId) {
            const cached = this.policyProductsById[productId];
            if (cached) {
              pol.policyProductId = cached;
              pol._product = cached;
              continue;
            }
            this.adminService.getPolicyById(productId).subscribe({
              next: (r: any) => {
                if (r?.success && r?.policy) {
                  pol.policyProductId = r.policy;
                  pol._product = r.policy;
                  this.policyProductsById[r.policy._id] = r.policy;
                }
              },
              error: () => {}
            });
          }
        } else {
          pol._product = product;
        }
      }
    }
  }

  closeCustomerModal() {
    this.showCustomerModal = false;
    this.selectedCustomer = null;
  }

  // --- User Policies Overview Helpers ---
  get filteredUserPoliciesCustomers(): any[] {
    const list = Array.isArray(this.customerDetails) ? this.customerDetails : [];
    const term = (this.userPoliciesSearch || '').trim().toLowerCase();
    if (!term) return list;
    return list.filter(c => {
      const name = (c?.customer?.name || '').toLowerCase();
      const email = (c?.customer?.email || '').toLowerCase();
      return name.includes(term) || email.includes(term);
    });
  }

  openUserPoliciesModal(c: any) {
    this.selectedUserPoliciesCustomer = c;
    this.showUserPoliciesModal = true;
    // Ensure policies have hydrated product info similar to customer modal
    if (c && Array.isArray(c.policies)) {
      for (const pol of c.policies) {
        const product = pol?.policyProductId;
        const needsFetch = !product || typeof product === 'string' || !product.code || !product.title;
        if (needsFetch) {
          const productId = typeof product === 'string' ? product : pol?.policyProductId?._id || pol?.policyProductId;
          if (productId) {
            const cached = this.policyProductsById[productId];
            if (cached) {
              pol.policyProductId = cached;
              pol._product = cached;
              continue;
            }
            this.adminService.getPolicyById(productId).subscribe({
              next: (r: any) => {
                if (r?.success && r?.policy) {
                  pol.policyProductId = r.policy;
                  pol._product = r.policy;
                  this.policyProductsById[r.policy._id] = r.policy;
                }
              },
              error: () => {}
            });
          }
        } else {
          pol._product = product;
        }
      }
    }
  }

  closeUserPoliciesModal() {
    this.showUserPoliciesModal = false;
    this.selectedUserPoliciesCustomer = null;
  }

  // Helper to resolve a policy product from either a populated object or a cached map
  policyByRef(ref: any): any {
    if (ref && typeof ref === 'object' && (ref.code || ref.title)) return ref;
    const id = typeof ref === 'string' ? ref : ref?._id;
    return id ? this.policyProductsById[id] : undefined;
  }

  private prefillCustomerPolicies() {
    for (const c of this.customerDetails) {
      if (!Array.isArray(c?.policies)) continue;
      for (const pol of c.policies) {
        const ref = pol?.policyProductId;
        if (ref && typeof ref === 'object' && (ref.code || ref.title)) {
          pol._product = ref;
          if (ref._id) this.policyProductsById[ref._id] = ref;
          continue;
        }
        const id = typeof ref === 'string' ? ref : ref?._id;
        if (id) {
          const cached = this.policyProductsById[id];
          if (cached) {
            pol._product = cached;
          } else {
            this.adminService.getPolicyById(id).subscribe({
              next: (r: any) => {
                if (r?.success && r?.policy) {
                  this.policyProductsById[r.policy._id] = r.policy;
                  pol._product = r.policy;
                }
              },
              error: () => {}
            });
          }
        }
      }
    }
  }

  logout() {
    this.auth.logout();
    this.router.navigate(['/login']);
  }

  // Called when name input changes while creating an agent to auto-generate email
  onAgentNameInput() {
    if (this.agentFormMode !== 'create') return;
    const rawName: string = (this.agentForm.name || '').trim();
    // Detect manual email edits: if current email not equal to last auto and last auto is set
    if (this.lastAutoGeneratedEmail && this.agentForm.email !== this.lastAutoGeneratedEmail) {
      this.emailManuallyEdited = true;
    }
    if (!rawName) {
      if (!this.emailManuallyEdited) {
        this.agentForm.email = '';
        this.lastAutoGeneratedEmail = '';
        this.lastAutoName = '';
      }
      return;
    }
    const slug = rawName
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .trim()
      .replace(/\s+/g, '.');
    if (!slug) return;
    const autoEmail = `${slug}@agent.com`;
    // Only overwrite if user hasn't manually changed email or email empty
    if (!this.emailManuallyEdited || !this.agentForm.email || this.agentForm.email === this.lastAutoGeneratedEmail || this.lastAutoName === rawName) {
      this.agentForm.email = autoEmail;
      this.lastAutoGeneratedEmail = autoEmail;
      this.lastAutoName = rawName;
    }
  }

  // Called when user types in email to mark manual edit (bind to input event if desired later)
  onAgentEmailInput() {
    if (this.agentFormMode === 'create') {
      if (this.agentForm.email !== this.lastAutoGeneratedEmail) {
        this.emailManuallyEdited = true;
      }
    }
  }

  // --- View modals handlers ---
  openAgentView(a: any) {
    this.selectedAgentView = a;
    this.showAgentViewModal = true;
  }
  closeAgentViewModal() {
    this.showAgentViewModal = false;
    this.selectedAgentView = null;
  }

  openPolicyProductView(p: any) {
    this.selectedPolicyProductView = p;
    this.showPolicyProductViewModal = true;
  }
  closePolicyProductViewModal() {
    this.showPolicyProductViewModal = false;
    this.selectedPolicyProductView = null;
  }

  openClaimView(c: any) {
    this.selectedClaimView = c;
    this.showClaimViewModal = true;
  }
  closeClaimViewModal() {
    this.showClaimViewModal = false;
    this.selectedClaimView = null;
  }

  // Modal helper methods
  showConfirmationModal(title: string, message: string, detail1: string, detail2: string, action: string, id: string) {
    this.confirmModalData = { title, message, detail1, detail2 };
    this.pendingAction = { action, id };
    this.showConfirmModal = true;
  }

  showSuccessMessage(title: string, message: string) {
    this.successModalData = { title, message };
    this.showSuccessModal = true;
  }

  confirmAction() {
    if (this.pendingAction) {
      switch (this.pendingAction.action) {
        case 'approve-claim':
          this.confirmApproveClaim(this.pendingAction.id);
          break;
        case 'reject-claim':
          this.confirmRejectClaim(this.pendingAction.id);
          break;
        case 'approve-policy':
          this.confirmApprovePolicy(this.pendingAction.id);
          break;
        case 'reject-policy':
          this.confirmRejectPolicy(this.pendingAction.id);
          break;
      }
    }
  }

  cancelAction() {
    this.showConfirmModal = false;
    this.confirmModalData = null;
    this.pendingAction = null;
  }

  closeSuccessModal() {
    this.showSuccessModal = false;
    this.successModalData = null;
  }
}
